#!/usr/bin/env node

/**
 * sardine-process — CLI runner for SARdine workflow YAML files.
 *
 * Reads a workflow .yaml file generated by the SARdine browser app and
 * replays the same load → subset → export pipeline on a collection of files.
 *
 * Usage:
 *   sardine-process workflow.yaml                     # process the file in the YAML
 *   sardine-process workflow.yaml --files '*.h5'      # apply to glob of files
 *   sardine-process workflow.yaml --list files.txt    # apply to list of files
 *   sardine-process workflow.yaml --dir /data/gcov    # all .h5 files in directory
 *
 * Options:
 *   --files <glob>    Glob pattern for input files
 *   --list <file>     Text file with one input path per line
 *   --dir <path>      Directory of .h5 files
 *   --output <dir>    Override output directory from YAML
 *   --dry-run         Show what would be processed without writing
 *   --help            Show this help
 *
 * The YAML file captures all processing parameters: source type, dataset,
 * subset bbox, multilook, contrast, colormap, stretch, export mode, etc.
 * The ${input} placeholder in source.path is replaced per-file.
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync } from 'node:fs';
import { resolve, basename, join, extname } from 'node:path';
import { glob } from 'node:fs/promises';

// ---------------------------------------------------------------------------
// YAML parser (minimal, handles our known schema without js-yaml)
// ---------------------------------------------------------------------------
function parseYAML(text) {
  const result = {};
  const stack = [{ obj: result, indent: -1 }];

  for (const rawLine of text.split('\n')) {
    // Skip comments and blank lines
    const trimmed = rawLine.replace(/#.*$/, '').trimEnd();
    if (!trimmed || !trimmed.trim()) continue;

    const indent = rawLine.search(/\S/);
    const line = trimmed.trim();

    // Pop stack until we find a parent at lower indent
    while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
      stack.pop();
    }
    const parent = stack[stack.length - 1].obj;

    const match = line.match(/^([\w$]+):\s*(.*)?$/);
    if (!match) continue;

    const [, key, rawVal] = match;
    const val = (rawVal || '').trim();

    if (!val) {
      // Nested object
      const child = {};
      parent[key] = child;
      stack.push({ obj: child, indent });
    } else {
      // Scalar or array
      parent[key] = parseValue(val);
    }
  }

  return result;
}

function parseValue(val) {
  // Inline array: [1, 2, 3]
  if (val.startsWith('[') && val.endsWith(']')) {
    const inner = val.slice(1, -1);
    if (inner.trim() === '' || inner.trim() === 'null') return null;
    return inner.split(',').map(s => {
      const t = s.trim();
      const n = Number(t);
      return isNaN(n) ? t : n;
    });
  }
  // Booleans
  if (val === 'true') return true;
  if (val === 'false') return false;
  if (val === 'null') return null;
  // Numbers
  const num = Number(val);
  if (!isNaN(num) && val !== '') return num;
  // Quoted strings
  if ((val.startsWith('"') && val.endsWith('"')) ||
      (val.startsWith("'") && val.endsWith("'"))) {
    return val.slice(1, -1);
  }
  return val;
}

// ---------------------------------------------------------------------------
// CLI argument parsing
// ---------------------------------------------------------------------------
function parseArgs(argv) {
  const args = { files: null, list: null, dir: null, output: null, dryRun: false, help: false, yamlFile: null };
  let i = 2; // skip node and script path
  while (i < argv.length) {
    const arg = argv[i];
    switch (arg) {
      case '--files': args.files = argv[++i]; break;
      case '--list': args.list = argv[++i]; break;
      case '--dir': args.dir = argv[++i]; break;
      case '--output': args.output = argv[++i]; break;
      case '--dry-run': args.dryRun = true; break;
      case '--help': case '-h': args.help = true; break;
      default:
        if (!arg.startsWith('-') && !args.yamlFile) {
          args.yamlFile = arg;
        } else {
          console.error(`Unknown option: ${arg}`);
          process.exit(1);
        }
    }
    i++;
  }
  return args;
}

function printHelp() {
  console.log(`
sardine-process — Batch SAR processing from SARdine workflow YAML

Usage:
  sardine-process <workflow.yaml> [options]

Options:
  --files <glob>    Glob pattern for input files (e.g. '*.h5')
  --list <file>     Text file with one input path per line
  --dir <path>      Directory of .h5/.he5 files
  --output <dir>    Override output directory
  --dry-run         Show what would be processed
  -h, --help        Show this help

Examples:
  sardine-process my-workflow.yaml --files '/data/gcov/*.h5'
  sardine-process my-workflow.yaml --dir /data/gcov --output ./results
  sardine-process my-workflow.yaml --list scenes.txt --dry-run

The workflow YAML is generated by the SARdine browser app's Workflow panel.
  `.trim());
}

// ---------------------------------------------------------------------------
// Resolve input files
// ---------------------------------------------------------------------------
async function resolveInputFiles(args, workflow) {
  const files = [];

  if (args.files) {
    // Glob pattern
    for await (const entry of glob(args.files)) {
      files.push(resolve(entry));
    }
  } else if (args.list) {
    // Line-separated file list
    const content = readFileSync(resolve(args.list), 'utf-8');
    for (const line of content.split('\n')) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        files.push(resolve(trimmed));
      }
    }
  } else if (args.dir) {
    // All HDF5 files in directory
    const dir = resolve(args.dir);
    const entries = readdirSync(dir);
    for (const entry of entries) {
      const ext = extname(entry).toLowerCase();
      if (['.h5', '.hdf5', '.he5', '.tif', '.tiff'].includes(ext)) {
        files.push(join(dir, entry));
      }
    }
  } else {
    // Single file from YAML
    const path = workflow?.sardine?.source?.path;
    if (path && !path.includes('${input}')) {
      files.push(resolve(path));
    }
  }

  return files.sort();
}

// ---------------------------------------------------------------------------
// Format workflow summary
// ---------------------------------------------------------------------------
function formatWorkflowSummary(wf) {
  const s = wf.sardine || {};
  const lines = [];
  lines.push(`  Type:        ${s.source?.type || '?'}`);
  if (s.dataset) {
    lines.push(`  Frequency:   ${s.dataset.frequency || '?'}`);
    lines.push(`  Mode:        ${s.dataset.mode || 'single'}`);
    if (s.dataset.mode === 'rgb') {
      lines.push(`  Composite:   ${s.dataset.composite}`);
    } else {
      lines.push(`  Polarization:${s.dataset.polarization || '?'}`);
    }
  }
  if (s.subset?.bbox) {
    lines.push(`  Subset:      [${s.subset.bbox.join(', ')}] ${s.subset.crs || ''}`);
  } else {
    lines.push(`  Subset:      full extent`);
  }
  if (s.processing) {
    const p = s.processing;
    lines.push(`  dB:          ${p.decibels}`);
    lines.push(`  Multilook:   ${p.multilook}`);
    lines.push(`  Stretch:     ${p.stretch}`);
    lines.push(`  Gamma:       ${p.gamma}`);
    lines.push(`  Colormap:    ${p.colormap}`);
    lines.push(`  Contrast:    ${JSON.stringify(p.contrast)}`);
  }
  if (s.output) {
    lines.push(`  Format:      ${s.output.format}`);
    lines.push(`  Export mode: ${s.output.mode}`);
    lines.push(`  Output dir:  ${s.output.directory}`);
  }
  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------
async function main() {
  const args = parseArgs(process.argv);

  if (args.help || !args.yamlFile) {
    printHelp();
    process.exit(args.help ? 0 : 1);
  }

  // Read and parse YAML
  const yamlPath = resolve(args.yamlFile);
  if (!existsSync(yamlPath)) {
    console.error(`Workflow file not found: ${yamlPath}`);
    process.exit(1);
  }

  const yamlText = readFileSync(yamlPath, 'utf-8');
  const workflow = parseYAML(yamlText);

  if (!workflow.sardine) {
    console.error('Invalid workflow: missing top-level "sardine" key');
    process.exit(1);
  }

  console.log('SARdine Workflow Processor');
  console.log('=========================\n');
  console.log('Workflow:');
  console.log(formatWorkflowSummary(workflow));
  console.log('');

  // Resolve output directory
  const outputDir = resolve(args.output || workflow.sardine.output?.directory || './output');

  // Resolve input files
  const inputFiles = await resolveInputFiles(args, workflow);
  if (inputFiles.length === 0) {
    console.error('No input files found. Use --files, --dir, or --list to specify inputs.');
    process.exit(1);
  }

  console.log(`Input files (${inputFiles.length}):`);
  for (const f of inputFiles) {
    console.log(`  ${f}`);
  }
  console.log(`\nOutput: ${outputDir}`);
  console.log('');

  if (args.dryRun) {
    console.log('[dry-run] Would process the above files with the workflow parameters.');
    console.log('[dry-run] To actually process, remove --dry-run.');
    process.exit(0);
  }

  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
    console.log(`Created output directory: ${outputDir}`);
  }

  // Process each file
  const wf = workflow.sardine;
  let processed = 0;
  let failed = 0;

  for (const inputFile of inputFiles) {
    const name = basename(inputFile, extname(inputFile));
    console.log(`\n--- Processing: ${basename(inputFile)} ---`);

    try {
      // Build output filename
      const ml = wf.processing?.multilook || 4;
      const mode = wf.output?.mode || 'raw';
      const pol = wf.dataset?.polarization || 'data';
      const outName = `${name}_${pol}_ml${ml}_${mode}.tif`;
      const outPath = join(outputDir, outName);

      // NOTE: Full processing requires importing the SARdine loaders,
      // which depend on browser APIs (File, h5wasm WASM, etc.).
      // This CLI runner currently operates as a job planner — it validates
      // the workflow, resolves files, and prepares the output structure.
      //
      // For actual headless processing, integration options:
      //   1. Node.js h5wasm + custom file adapter (planned)
      //   2. Server-mode sardine-launch with HTTP API
      //   3. Python fallback via GDAL/rasterio for subset+export

      // Write a per-file processing manifest
      const manifest = {
        input: inputFile,
        output: outPath,
        workflow: yamlPath,
        parameters: {
          frequency: wf.dataset?.frequency || 'A',
          polarization: wf.dataset?.polarization || 'HHHH',
          mode: wf.dataset?.mode || 'single',
          composite: wf.dataset?.composite || null,
          multilook: ml,
          decibels: wf.processing?.decibels ?? true,
          stretch: wf.processing?.stretch || 'linear',
          gamma: wf.processing?.gamma || 1.0,
          colormap: wf.processing?.colormap || 'grayscale',
          contrast: wf.processing?.contrast || [-25, 0],
          subset: wf.subset?.bbox || null,
          crs: wf.subset?.crs || null,
          exportMode: mode,
        },
        timestamp: new Date().toISOString(),
      };

      const manifestPath = join(outputDir, `${name}_manifest.json`);
      writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
      console.log(`  Manifest: ${manifestPath}`);
      console.log(`  Output:   ${outPath}`);
      console.log(`  Status:   ready (manifest written)`);
      processed++;
    } catch (e) {
      console.error(`  FAILED: ${e.message}`);
      failed++;
    }
  }

  console.log(`\n=========================`);
  console.log(`Done. ${processed} prepared, ${failed} failed.`);
  console.log(`Manifests written to: ${outputDir}`);
  console.log(`\nTo process with Python/GDAL:`);
  console.log(`  python sardine-batch.py ${outputDir}/*.json`);
  console.log(`\nTo process with sardine-launch server:`);
  console.log(`  curl -X POST http://localhost:8050/api/process -d @${outputDir}/<manifest>.json`);
}

main().catch(e => {
  console.error(`Fatal: ${e.message}`);
  process.exit(1);
});
